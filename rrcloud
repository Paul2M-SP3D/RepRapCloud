#!/usr/bin/perl

# -- RepRap Cloud, written by Rene K. Mueller <spiritdude@gmail.com>
#
$VERSION = '0.015';
$APPNAME = 'RepRapCloud';
#
# History:
# 2013/03/04: 0.015: preparing general interface for several dbs (mongodb, mysql, flatfile (default))
# 2013/03/03: 0.014: logging, and some code clean-up
# 2013/03/02: 0.013: checking preargN for validity
# 2013/03/02: 0.012: openjscad service included
# 2013/02/25: 0.011: rrcloudrc at various places considered, --local force local
# 2013/02/24: 0.009: replaced `` by fork & exec combo, a bit code cleaning up 
# 2013/02/24: 0.008: additional prearguments (e.g. --load=file.conf as for slic3r)
# 2013/02/23: 0.007: directory support as input (experimental, disabled)
# 2013/02/22: 0.005: multiple input files supported, added 'echo' service
# 2013/02/19: 0.002: remote stuff slowly working, not yet complete
# 2013/02/18: 0.001: first version, simple services of openscad, slic3r working
#
# Description:
#
# Notions: cli (command-line interface), cgi (common gateway interface = web)
#
# The main aim is provide a very simple framework to provide remote (a)synchronous services:
#    + 3d triangulation (openscad): .scad to .stl 
#    + 3d slicing (slic3r): .stl to .gcode
#    - 3d printing: .gcode to machine(s)
#    - 3d raytracing (povray): .stl/.pov to .png (just for sake of fun)
#
# Examples:
#  rrcloud openscad cube.scad -ocube.stl
#      or
#  openscad.cloud cube.scad -ocube.stl
#     creates cube.stl
#
# further aim (not yet implemented):
#  rrcloud openscad+slic3r:conf=prusa1.conf+print3d cube.scad
#     would print cube.scad (.stl -> .gcode with profile prusa1.conf) to default 3d printer
#
# rrcloud is a
#   x command-line program, working locally
#   x command-line client, sending off to remote server and retrieve info and then data
#   x alias for all services <service>.cloud (e.g. openscad.cloud, slic3r.cloud) being command-line compatible with originals
#   x web-server (cgi), receiving tasks and do them, and answer to client queries, plus browser access
#   - command-line dispatcher to handle queue of sequential tasks (e.g. .scad -> .stl -> .gcode -> printing)
#
#  x = implemented
#  - = to do
#
# all in one ;-) (seriously: as most of the code is common anyway)
#
# Limitations:
# - one/many file input, one file output
#
# Todo:
# - how long are the data retained (24hrs, user-defineable)
# 
# Disclaimer:
# There is no security or encryption done, very likely this service can be abused to take over a server.
#
# == DO NOT RUN ON PUBLIC SITES until a proper code review has occured! ==

use CGI;
use IO::Handle;
use File::Copy;
use Cwd;
use Time::HiRes qw(time usleep);
use POSIX;

open(LOG,">>tasks/global.log");

my $verbose = 0;     # -- 0, 1 or 2 -- for debugging

my(%db,%arg,@err);

$db{type} = 'flatfile';    # -- flatfile (default), mongodb, mysql (not yet, but preparing)
$db{dir} = '.';

$arg{port} = 4468;         # -- don't change it unless you must
$arg{maxDataRetention} = 24;   # -- hours

delete $ENV{DISPLAY};      # -- openscad wants to open DISPLAY if set, we don't do this

# -- create folders if necessary
mkdir "tasks" unless(-d "tasks");
foreach (qw(in out info log queue)) {
   mkdir "tasks/$_" unless(-d "tasks/$_");
}

# -- become aware what we can do
foreach my $s (<services/*>) {
   my $c = readConfig($s);
   $s =~ s/.+\///; $s =~ s/\..*$//;
   $service{$s} = $c;
}
print STDERR "supported services: ",join(", ",keys %service),"\n" if($verbose);

# -- local and global configuration
foreach my $f ("$ENV{HOME}/.rrcloudrc",'./rrcloudrc') {
   if(open(F,$f)) {
      print STDERR "parsing $f ...\n" if($verbose);
      while(<F>) {
         chop;
         next if(/^\s*#/);          # -- ignore comments
         s/\s*#.*//;                # -- remove trailing comments
         $arg{$1} = $2 if(/^\s*([^\s:=]+)\s*[:=]\s*(\S.+)\s*$/);
      }
      close(F);
   }
}
$arg{timeout} = 30*60 unless($arg{timeout});

my($q,%in,%me);

if($0=~/^(\S+)\.cloud$/) {    # -- local wrapper, e.g. slic3r.cloud
   my($s) = $1; my @a;
   my $lout;
   
   $s =~ s/^.+\///;           # -- remove any path in front/head, leave cmd/service 

   my(@s) = split(/,/,$arg{"$s.servers"}?$arg{"$s.servers"}:$arg{servers});
   if($#s>=0) {
      $arg{s} = @s[int(rand()*(($#s+1)*1000))%($#s+1)];   # -- random server
   }
   
   $me{type} = 'cli';
   $arg{synchronous}++;       # -- enforce synchronous operation
   $in{service} = $s;
   
   my $out = $service{$s}->{output};     # -- e.g. '-o=$fileOut'
   $out =~ s/\$fileOut//;                # -- e.g. '-o='
   my $in = $service{$s}->{argInput};    # -- e.g. '--load=$fileIn'
   $in =~ s/\$fileIn//;                  # -- e.g. '--load='
   
   my $n = 0;
   while($#ARGV>=0) {
      my $a = shift(@ARGV);
      if(-e $a) {
         $in{"fileIn$n"} = $a;
         $n++;
         
      } elsif(index($a,$out)==0) {               # -- original output?
         my $o = $a;
         $lout = substr($o,length($out));        # -- original filename to write things to

      } elsif(index($a,$in)==0) {                # -- additional input
         $in{"fileIn$n"} = substr($a,length($in));
         $in{"prearg$n"} = $in;                  # -- remember prearg(ument) for this input file (e.g. '--load=')
         $n++;
      } else {
         print STDERR "ERROR: not supported switch or file not found '$a'\n";
         exit 1;
      }
      push(@a,$a);
   }
   my $cmd = $service{$s}->{cmd};
   unless($arg{s}) {                             # -- no server defined, we execute locally
      print STDERR "local: $cmd @a\n" if($verbose);
      exec($cmd,@a);

   } elsif($lout) {
      print STDERR "remote ($arg{s}): $cmd @a\n" if($verbose);
      # $in{args} = join(' ',@a);
      my(%r) = myExecRemote($arg{s},service=>$s,%in);
      if(-f $r{out}) {
         copy($r{out},$lout);
      } else {
         print STDERR "ERROR: remote service failed, no results\n";
         exit -1;
      }
   } else {
      print STDERR "ERROR: likely wrong command-line argument for output, something like '$out' ($service{$s}->{output}) expected\n";
      exit -1;
   }
   exit 0;
}
   
if($#ARGV>=0||$ENV{HOME}) {               # -- likely cli
   my $n = 0;
   while($#ARGV>=0) {
      $_ = shift(@ARGV);
      $arg{$1} = $2, next if(/^--([^=\s]+)=(\S+)/);
      $arg{$1}++, next if(/^--([^=\s]+)/);
      $in{service} = $_, next unless($in{service});
      if(-e $_) {
         $in{"fileIn$n"} = $_, $n++, next;
      } else {
         $in{id} = $_, next;
      }
   }
   $me{type} = 'cli';
   
} else {                                  # -- we are a cgi
   $q = CGI->new;
   %in = $q->Vars;
   $me{type} = 'cgi';
}

if(!$arg{local}&&!$arg{s}) {
   my(@s) = split(/,/,$arg{"$s.servers"}?$arg{"$s.servers"}:$arg{servers});
   if($#s>=0) {
      $arg{s} = @s[int(rand()*(($#s+1)*1000))%($#s+1)];   # -- random server
   }
}

# -- debugging
if(0) {
   print "Content-type: text/plain\n\n" if($me{type}eq'cgi');
   foreach(sort keys %in) {
      print "$_: $in{$_}\n";
   }
}
if(0) {
   foreach(sort keys %ENV) {
      print "$_: $ENV{$_}\n";
   }
}

$in{service} =~ s/\W//;    # -- sanetize input

$in{service} = 'info' if($me{type}eq'cli'&&!$in{service});

if(($in{service}||$ENV{REQUEST_METHOD}=~/PUT/)&&-f "services/$in{service}.conf") {  # -- demand a task to be executed
   my @fin;
   
   for(my $n=0; $in{"fileIn$n"}; $n++) {
      my $f = acquireFileIn("fileIn$n");
      $in{"fileIn$n"} = $f;
      push(@fin,$f);
   }
   
   if($arg{s}) {     # -- we are a client, contacting the remote server
      myLog("request remote",%in,server=>$arg{s});
      my(%r) = postServer($arg{s},service=>$in{service},%in);

      if($r{id}) {                  # -- we store the info, query later again for completeness
         $r{in} = join(",",@fin);   # -- make sure we maintain the in(put)-files locally
         $r{server} = $arg{s};      # -- back-reference (important!)
         putTaskInfo($r{id},%r);
         myLog("response $arg{s}",%r);
         print "id: $r{id}\n";
         
      } else {
         print STDERR "ERROR: http://$arg{s}:$arg{port} doesn't seem to support $APPNAME\n";
      }
      
   } else {          # -- we are local, or a server which received a request, something to compute here
      my $id = startTask($in{service},%in);

      # -- parent & child come here! (be aware)
   }

} elsif($in{service} eq 'status'||$in{service} eq 'info') {
   my(@t);
   
   if($in{id}) {                    # -- query info
      push(@t,$in{id});
   } else {
      @t = getTaskList();
   }
   myLog("query task info (".($#t+1).")");
   my $n = 0;
   print "Content-type: text/plain\n\n" if($me{type}eq'cgi');
   
   print "[\n" if($in{format}eq'json'&&!$in{id});
   foreach my $id (@t) {
      my %i = getTaskInfo($id);

      if($i{etime}&&(time()-$i{etime}>$arg{maxDataRetention}*60*60)) {     # -- garbage collector
         deleteTask($i{id},%i);
         next;
      }
      if($i{server}&&$i{status}eq'busy') { #&&$me{type}ne'cgi') {
         print STDERR "update status of $id\n" if($verbose);
         my(%r) = postServer($i{server},service=>$in{service},id=>$id);
         foreach (keys %r) {
            next if($_ eq 'in');
            $i{$_} = $r{$_} if(defined $r{$_});
         }
         if($i{status}eq'complete') {
            # -- retrieve resulting data from $i{server}/$r{out} -> $r{out}
            print STDERR "results of $id retrieving remotely http://$i{server}:$arg{port}/$r{out}\n" if($verbose);
            getRemoteFile($i{server},$r{out});
         }
         # -- at each query when 'busy' we download the log file
         getRemoteFile($i{server},"tasks/log/$id");

         putTaskInfo($id,%i);          # -- possibly 'complete', log and data for sure arrived
         myLog("update task info",%i);
      }
      if($me{type}eq'cli') {
         print "=== id: $id\n";
         foreach my $k (sort keys %i) {
            print "\t$k: $i{$k}\n";
         }
         print "\n";
      } elsif($me{type}eq'cgi') {
         print ", // #$n, $id\n" if($in{format}eq'json'&&$n>0);
         print "{\n" if($in{format}eq'json');
         foreach my $k (sort keys %i) {
            if($in{format}eq'json') {
               print "\t$k: \"$i{$k}\",\n";
            } else {
               print "$k: $i{$k}\n";
            }
         }
         print "}\n" if($in{format}eq'json');
         if($ENV{HTTP_USER_AGENT}=~/Mozilla/&&$in{format}ne'json') {
            print "log (seen by browser only):\n";
            open(F,"tasks/log/$id");
            while(<F>) {
               print $_;
            }
            print "\n";
            close(F);
         }
         print "\n";
      }
      $n++;
   }
   print "]\n" if($in{format}eq'json'&&!$in{id});

# } elsif($in{service} eq 'delete') {   
} elsif($in{service} eq 'kill') {   
   killTask($in{id}) if($in{id});

# } elsif($in{service} eq 'suspend') {   
# } elsif($in{service} eq 'continue') {   

} else {
   myLog("query all tasks");
   if($me{type}eq'cgi') {
      if($ENV{HTTP_USER_AGENT}=~/Mozilla/) {     # -- browser
         my(@t) = reverse getTaskList();         # -- last listed first (reverse)
         print "Content-type: text/html\n\n";
         print "<html><head><title>$APPNAME @ $ENV{SERVER_NAME} ($VERSION): ",$#t+1," tasks</title><link rel='shortcut icon' href='/www/favicon.png'/></head><body><link rel=stylesheet href='/www/style.css'/>";
         print "<a href='https://github.com/Spiritdude/RepRapCloud'><img src='www/logo.png' class=logo></a> <div class=serverID>$ENV{SERVER_NAME}</div>\n";
         print "<div class=headerInfo>$APPNAME ($VERSION), ";
         print "Services: <b>",join(', ',sort keys %service),"</b><br>";
         print "Total <b>",($#t+1)," tasks</b> in pool ($arg{maxDataRetention} hrs max data retention)</div>";
         if($#t>=0) {
            print "<table class=taskList>";
            print "<tr><th>",join("</th><th>",(qw(. id service compute client status date duration in out comment))),"</th></tr>";
            foreach my $id (@t) {
               my %i = getTaskInfo($id);
               if(1) {
                  #my($buttons);
                  #foreach(qw(suspend stop delete)) {
                  #   $buttons .= "<img class=taskActionButton src='/www/task-${_}Off.png'>";
                  #}
                  print "<tr class=task$i{status}><td>",join("</td><td>",(
                        "<img class=taskStatusIcon src='www/task-status-$i{status}.png'>",
                        "<a href='/?service=info&id=$i{id}'>$i{id}</a>",
                        $i{service},
                        $i{server}?$i{server}:"local",
                        $i{server}?"":$i{client},
                        $i{status},
                        prettyDate($i{ctime}),
                        sprintf("%.3f",$i{etime}?$i{etime}-$i{ctime}:time()-$i{ctime})."s",
                        largeNum($i{sizeIn}/1024,2)."KB",
                        largeNum($i{sizeOut}/1024,2)."KB",
                        #$buttons,
                        $i{error}
                     )),"</td></tr>";
                  
               } else {
                  print "<b>$id</b>:<br>";
                  foreach (sort keys %i) {
                     print "<li>$_: $i{$_}\n";
                  }
                  print "<p>log:<br><tt>\n";
                  open(F,"tasks/log/$id");
                  while(<F>) {
                     print "$_<br/>\n";
                  }
                  print "</tt>\n";
                  close(F);
                  print "<hr>";
               }
            }
            print "</table>";
         }
         print "<div class=footer><a href='https://github.com/Spiritdude/RepRapCloud'><img src='/www/logo.png' height=20 border=0 align=absmiddle></a> $APPNAME $VERSION (<a href='https://github.com/Spiritdude/RepRapCloud'>check</a> for the latest version)</div>";
         print "</body></html>";
      } else {
         print "Content-type: text/plain\n\nrequested service '$in{service}' does not exist (yet)" 
      }
   } else {
      print STDERR "ERROR: requested service '$in{service}' does not exist (yet).\n";
   }
}

sub acquireFileIn {     # -- we acquire a local-file and make a copy (cli), or retrieved a file-upload and store it (cgi)
   my($fi) = @_;
   my($fn) = uniq();

   print STDERR "acquire file $fi -> $in{$fi} ($me{type}): " if($verbose>1);
   $fi = $in{$fi} if($in{$fi}&&$me{type}eq'cli');
   
   my($fh) = $q?$q->upload($fi):0;
   my($ext) = (($q&&$q->param($fi)?$q->param($fi):$fi)=~/\.([^\.]+)$/);    # -- some programs require proper extension, so we retrieve it now
   
   # -- info http://perldoc.perl.org/CGI.html#PROCESSING-A-FILE-UPLOAD-FIELD
   if($me{type}eq'cgi'&&-f $q->tmpFileName($fh)) {                         # -- uploaded file copy into tasks/in/
      if($ext eq 'tgz') {
         mkdir "tasks/in/$fn" unless(-d "tasks/in/$fn");
         # `cd tasks/in/$fn && tar xfz $q->tmpFileName($fh)`;                # -- untar if its .tgz into tasks/in/$fn
         
      } else {
         $fn .= ".$ext" if($ext);     
         copy($q->tmpFileName($fh),"tasks/in/$fn") || 
            push(@err,"file copy failed to tasks/in/$fn due '$!'");        # -- be aware of file permissions
      }

   } elsif($me{type}eq'cli'&&-e $fi) {                                     # -- local file copy into tasks/in/
      if(-d $fi) {
         $fn .= ".tgz";
         # `tar cfz tasks/in/$fn $fi`;                                       # -- tar it when it's a directory
         
      } else {
         $fn .= ".$ext" if($ext);                                          
         copy($fi,"tasks/in/$fn");
      }
      
   } else {
      print STDERR "ERROR: likely file not found $fi (me=$me{type})\n";
      exit 1;
   }
   print STDERR "tasks/in/$fn\n" if($verbose>1);
   return "tasks/in/$fn";
}
   
sub getTaskList {
   return db('query','tasks.info');
}

sub startTask {                           # -- service and input file(s), compute something here and now
   my($s,%in) = @_;
   my(@cmd);
   #my $id = ($ENV{HOST}?$ENV{HOST}:$ENV{SERVER_NAME})."@".uniq();
   my $id = uniq();

   $ENV{PATH} = $service{$s}->{path}      # -- limit search PATH
      if($service{$s}->{path});
   
   push(@cmd,$service{$s}->{cmd});        # -- main executable

   #foreach my $k (sort keys %in) {        # -- pass on the arguments (out of order)
   #   push(@cmd,"--$1=$in{$k}") if($k=~/^$s\.(\S+)/);
   #}

   my @fin;
   for(my $n=0; $in{"fileIn$n"}; $n++) {
      my $k = "fileIn$n";
      
      if($in{"prearg$n"}) {
         my $pa = $service{$s}{argInput}; $pa =~ s/\$fileIn//;

         if($pa&&$pa eq $in{"prearg$n"}) {          # -- approved prearg? (is prearg0 in service.conf:input line)
            push(@cmd,$in{"prearg$n"}.$in{$k});     # -- and push the input file(s) with prearg(ument) e.g. '--load='
            
         } else {
            push(@err,"not approved prearg$n: ".$in{"prearg$n"}." ($pa); wrong configuration or hacking attempt");
         }
         
      } else {
         push(@cmd,$in{$k});                  # -- and push the input file(s) raw
      }
      push(@fin,$in{$k});
   }

   my $o = $service{$s}->{output};        # -- compose output 
   my $fn;
   if($service{$s}->{fileOut}) {
      $fn = $service{$s}->{fileOut};
      $fn =~ s/\$id/$id/;
   } else {
      $fn = $id;
   }
   $o =~ s#\$fileOut#tasks/out/$fn#;      # -- form the output file
   push(@cmd,$o);
   
   my $pid = 0; my $forked;
   
   if(!$arg{synchronous}) {
      $pid = fork();                      # -- the UNIX magick starts here ...
      $forked++;
   }
   if($pid||$arg{synchronous}) {          # -- if forked, write as parent, or anyway (but not as child & parent)
      putTaskInfo($id,                    #       because only the parent knows the pid
         id=>$id,                         #    race condition: in few cases this is executed AFTER the child
         in=>join(',',@fin),              #                    has ended, and added etime already (fast execution)
         out=>join(',',map { $_="tasks/out/$_" } ($fn)),
         ctime=>time(),
         pid=>$pid,
         #args=>$in{args},
         cmd=>"@cmd",
         service=>$s,
         client=>$ENV{REMOTE_ADDR}?$ENV{REMOTE_ADDR}:'localhost',
         # server=$ENV{SERVER_NAME}?$ENV{SERVER_NAME}:'localhost,
         status=>'busy'
      );
   }
   if($pid==0) {                                # -- we are the child (asynchronous)
      print STDERR "execute '@cmd' (",($arg{synchronous}?"synchronous":"asynchronous"),")\n" if($verbose);
      myExec($id,@cmd);                         # -- execute the thing (it forks again), comes back when done

      my(%i) = getTaskInfo($id);                # -- we retrieve for sake of logging
      myLog("performed",%i);           # -- perfect time to log (after the task is done)

      #exit if($forked);
   }
   if($pid!=0||$arg{synchronous}) {             # -- parent (asynchronous) or already done job (synchronous)
      if($me{type}eq'cgi') {
         print "Content-type: text/plain\n\n";
         my(%i) = getTaskInfo($id);             # -- in case of asynchronous, we re-read the task info (could be simplified)
         foreach (sort keys %i) {
            print "$_: $i{$_}\n";
         }
         print "error: ",join(";",@err),"\n" if($#e>=0);

      } else {
         print "id: $id\n";
      }
   }
   return $id;
}

sub killTask { 
   my($id) = @_;
   my(%q) = getTaskInfo($id);
   if($q{status} eq 'busy'&&$q{pid}) {
      kill $q{pid};
      $q{status} = 'failed';
      putTaskInfo($id,%q);
   }
}

sub deleteTask {
   my($id,%i) = @_;

   return unless($id);
   %i = getTaskInfo($id) unless($i{id});     # -- full info provided, if not retrieve it
   killTask($id) if($i{status}eq'busy');     # -- kill task if it's still busy

   foreach(/,/,$i{in}) {            # -- delete input files
      unlink($_);
   }
   foreach(/,/,$i{out}) {           # -- delete output files
      unlink($_);
   }
   db('delete','tasks.info',$id);
}

sub getTaskInfo {
   my($id) = @_;
   my(%i);
   
   %i = db('get','tasks.info',$id);

   $i{sizeIn} = 0;
   foreach(split(/,/,$i{in})) {
      my($sz) = (stat($_))[7];
      $i{status} = 'failed', push(@err,"empty input file: $_") if($sz==0);
      $i{sizeIn} += $sz;
   }
   $i{sizeOut} = (stat($i{out}))[7];
   if($i{status}eq'complete'||$i{status}eq'failed') {
      $i{status} = 'failed', push(@err,"empty output file") if((stat($i{out}))[7]==0);
      push(@err,"empty log file") if((stat("tasks/log/$id"))[7]==0);
   }
   $i{error} = join(", ",@err) if($#err>=0);
   @err = ();
   
   # $i{status} = checkProcess($i{pid},$id,$i{cmd})?"busy":"failed" unless($i{status}eq'complete');

   return %i;
}

sub putTaskInfo {
   my($id,%r) = @_;
   db('set','tasks.info',$id,%r);
}

sub readConfig {
   my($f) = @_;
   my %s;

   return unless(open(F,$f));
   #print STDERR "reading $f\n" if($verbose);
   while(<F>) {
      chop;
      next if(/^\s*#/);       # -- ignore comments
      s/\s*#.*//;             # -- remove trailing comments
      $s{$1} = $2 if(/^\s*([^\s:=]+)\s*[:=]\s*(\S.+)\s*$/);
   }
   close(F);
   return \%s;
}

sub uniq {
   my $t = time();
   my $fn = join('-',         # -- creating unique id (for this machine)
      int($t),
      sprintf("%05d",($t-int($t))*100_000),
      sprintf("%06d",int(rand()*(1_000_000-1)))
   );
   return $fn;
}

sub checkProcess {               # -- doesn't work yet
   my($pid,$id,$cmd) = @_;
   my(%p);
   if(open(F,"/proc/$pid/cmdline")) {
      $_ = <F>; chop;
      s/\0/ /g;
      close(F);
   }
   return 1 if($_ eq $cmd);
   return 0;
}

sub myExec {
   my($id,@a) = @_;
   my($pid);
   my($st) = time();
   if(($pid=fork())==0) {                    # -- real perl magic here ...
      open STDOUT, '>', "tasks/log/$id";
      open STDERR, ">&STDOUT";
      STDOUT->autoflush(1);
      STDERR->autoflush(1);
      exec(@a);
      # -- never reaches here
      
   } else {
      wait;              # -- cmd has been ended (successful or failed)
      
      # -- program has finished, we update the info 
      my $n;
      while(1) {
         my %q = db('get','tasks.info',$id);
         if($q{id}) { # -- had parent/parent time to write the data?
            db('update','tasks.info',$id,status=>'complete',etime=>time());
            last;
         } else {
            usleep(100_000), next;
            last if($n++>4);
         }
      }
   }
}

sub postServer {
   my($s,%i) = @_; 
   my(@cmd,%r);
   
   push(@cmd,'curl','-s');

   foreach(keys %i) {
      my $f; $f = '@' if(-f $i{$_});      # -- is a file
      push(@cmd,'-F',"$_=$f$i{$_}");
   }
   push(@cmd,"http://$s:$arg{port}");
   
   print STDERR "-> $s: request service/info ('@cmd')\n" if($verbose);

   # -- insecure: $_ = `@cmd`;      # -- we request the service or info remotely, and receive a feedback

   my $pid = open(READ,"-|");       # -- more secure, but complicate ... see http://perldoc.perl.org/perlipc.html
   if($pid==0) {
      exec(@cmd);
   } else {
      my $res;
      while(<READ>) {
         $res .= $_;
      }
      close(READ);
      $_ = $res;
   }
   
   print STDERR "<- $s responds: $_\n" if($verbose);

   %r = string2meta($_);
   $r{server} = $s;                 # -- add back-reference (important!)

   return %r;
}

sub myExecRemote {
   my($s,%i) = @_;
   
   my @fin;
   for(my $n=0; $i{"fileIn$n"}; $n++) {
      my $f = acquireFileIn("fileIn$n");
      $i{"fileIn$n"} = $f;
      push(@fin,$f);
   }
   $i{in} = join(",",@fin);

   myLog("request remote",%i,server=>$s);
   my(%r) = postServer($s,%i);
   my $st = time();

   $r{in} = $i{in};
   
   print STDERR "ERROR: $s doesn't run RepRapCloud\n" if(!$r{id});
   
   while($r{id}) {
      my(%q) = postServer($s,service=>'info',id=>$r{id});
      if($q{status}eq'complete'||$q{status}eq'failed') {
         if($q{status}eq'complete') {
            getRemoteFile($s,$r{out});
         }
         getRemoteFile($s,"tasks/log/$r{id}");
         foreach (keys %q) {
            next if($_ eq 'in');
            $r{$_} = $q{$_};
         }
         putTaskInfo($r{id},%r);
         myLog("performed remote",%q);
         last;
      } elsif($in{status}) {
         ;
      } else {
         print STDERR "ERROR: $s doesn't run RepRapCloud\n";
         last;
      }
      sleep $w; $w += 2; $w = 10 if($w>10);
      last if($arg{timeout}&&(time()-$st)>$arg{timeout});
   }    
   return %r;
}

sub getRemoteFile {
   my($s,$p) = @_;

   # -- insecure: `wget -q http://$s:$arg{port}/$p -O $p`;
   if(fork()==0) {      # -- properly done:
      # exec('wget','-q',"http://$s:$arg{port}/$p",'-O',$p);     # -- more secure
      exec('curl','-s',"http://$s:$arg{port}/$p",'-o',$p);     # -- more secure
   } else {
      wait;
   }
}

sub string2meta {
   my($s) = @_;
   my(%r);
   #print "string -> data:\n" if($verbose);
   foreach (split(/\n/,$s)) {       # -- processing feedback
      $r{$1} = $2 if(/^([^\s:]+): (\S.+)\s*$/);
      #print STDERR "\t$1: $2\n" if($1&&$verbose);
   }
   return %r;
}

sub meta2string {
   my(%r) = @_;
   my($s);
   #print STDERR "data -> string:\n" if($verbose);
   foreach (sort keys %r) {
      $s .= "$_: $r{$_}\n";
   }
   #print STDERR $s if($verbose);
   return $s;
}

sub prettyDate {
   @_ = localtime($_[0]);
   return sprintf("%04d/%02d/%02d %02d:%02d:%02d",$_[5]+1900,$_[4]+1,$_[3],$_[2],$_[1],$_[0]);
}

sub prettyTime {
   my($t) = @_;
   sprintf("%sd %02dh %02dm %02ds",largeNum(int($t/(24*60*60)),0),int($t/(60*60))%24,int($t/60)%60,int($t)%60);
}

sub largeNum {
   my($a,$n) = @_;
   my($s,$i);
   $s .= sprintf(".%0${n}d",int(($a-int($a))*100)%100) if($n);
   while($a||$i==0) {
      $s = ",$s" if($i&&($i%3)==0);
      $s = ($a%10).$s;
      $a = int($a/10);
      $i++;
   }
   return $s;
}

sub myLog {
   my($c,%i) = @_;
   my($t) = time();
   my $m = join(' - ',
      $ENV{REMOTE_ADDR}?$ENV{REMOTE_ADDR}:"localhost",
      prettyDate($t),$t,$me{type},"\"$c\"");
   my $n;
   $m .= ": ";
   foreach (qw(id service server client status ctime etime sizeIn sizeOut)) {
      if($i{$_}) {
         $m .= ',' if($n++);
         $m .= "$_:$i{$_}";
      }
   }
   print LOG "$m\n";
}

sub db {       # -- NoSQL CRUD: Create, Read, Update, Delete 
   my($c,$p,$d,@a) = @_;   # -- command, database/path, document, %data (key-value) or @list of keys in case of delete
   my %q;
   
   if($db{type}eq'flatfile') {
      $p =~ s/\./\//g;                 # -- convert path to actual filepath
      my $fp = "$db{dir}/$p";
      unless(-d $fp) {                 # -- doesn't exist?
         my $lp;
         foreach (split(/\//,$fp)) {
            $lp .= "$_/";
            unless(-d "$db{dir}/$lp") {
               print STDERR "creating $db{dir}/$lp\n" if($verbose);
               mkdir "$db{dir}/$lp" || die "ERROR: cannot create directory $db{dir}/$lp: $!\n";
            }
         }
      }
   }
   if($c eq 'set'||$c eq 'put'||$c eq 'write'||$c eq 'create') {
      if($db{type}eq'mongodb') {          # -- mongodb
      } elsif($db{type}eq'mysql') {       # -- mysql
      } elsif($db{type}eq'sqlite') {      # -- sqlite
      } else {                            # -- flatfile
         my $n;
         while(-e "$db{dir}/$p/$d.new") {    # -- make sure not another process is updating
            usleep 100_000;
            last if($n++>3);
         }
         %q = @a;
         open(F,">$db{dir}/$p/$d.new") || die "ERROR: cannot write to $db{dir}/$p/$d.new: $!\n";
         foreach (sort keys %q) {
            print F "$_: $q{$_}\n";
         }
         close(F);
         rename("$db{dir}/$p/$d.new","$db{dir}/$p/$d");
      }
   } elsif($c eq 'query'||$c eq 'search') {
      if($db{type}eq'mongodb') {          # -- mongodb
      } elsif($db{type}eq'mysql') {       # -- mysql
      } elsif($db{type}eq'sqlite') {      # -- sqlite
      } else {                            # -- flatfile
         opendir(D,"$db{dir}/$p");
         my(@t) = sort grep(!/\./,readdir(D));     # -- ignore . and .. 
         closedir(D);
         return @t;
      }
      return;
      
   } elsif($c eq 'get'||$c eq 'read') {
      if($db{type}eq'mongodb') {          # -- mongodb
      } elsif($db{type}eq'mysql') {       # -- mysql
      } elsif($db{type}eq'sqlite') {      # -- sqlite
      } else {                            # -- flatfile
         open(F,"$db{dir}/$p/$d");
         while(<F>) {
            chop;
            $q{$1} = $2 if(/^(\S+): (.*)$/);
         }
         close(F);
      }
      return %q;
            
   } elsif($c eq 'update') {
      if($db{type}eq'mongodb') {          # -- mongodb
      } elsif($db{type}eq'mysql') {       # -- mysql
      } elsif($db{type}eq'sqlite') {      # -- sqlite
      } else {                            # -- flatfile
         %q = db('read',$p,$d);           # -- I love recursion!! ;-)
         my %a = @a;
         foreach (keys %a) {
            $q{$_} = $a{$_};
         }
         db('write',$p,$d,%q);
      }
      
   } elsif($c eq 'delete') {
      if($db{type}eq'mongodb') {          # -- mongodb
      } elsif($db{type}eq'mysql') {       # -- mysql
      } elsif($db{type}eq'sqlite') {      # -- sqlite
      } else {                            # -- flatfile
         if($#a<0) {
            return unlink("$db{dir}/$p/$d");
         } else {
            %q = db('read',$p,$d);
            foreach (@a) {
               delete $q{$_};
            }
            db('write',$p,$d,%q);
         }
      }
   } else {
      print STDERR "db() c = '$c' not implemented (yet)\n";
   }
}

